#logstash config
input {
    file {
        type => "log4j"
        path => [ "D:\Downloads\-\CSI-4737\logs\my.log" ]
        codec => multiline {
            pattern => "(^\d+\serror)|(^.+Exception: .+)|(^\s+at .+)|(^\?s+... \d+ more)|(^\s*Caused by:.+)"
            what => "previous"
        }
        start_position => "beginning"
        sincedb_path => "D:/dev/prj/elk/4737/.sincedb"
    }
}

filter {
    #remove_tag => [ "_grokparsefailure" ]
    #break_on_match => false
    if [type] == "log4j" {
        grok {
            patterns_dir => "./patterns"
	    match => [ "message", "%{LOG4JLOG}" ]
        }
        #grep {
            #drop => false #grep normally drops non-matching events
        #    match => {"logmessage" => "(Analyzing)%{GREEDYDATA}" }
        #    add_tag => [ "tag_a" ]
        #}
        date {
            match => [ "timestamp", "yyyy-MM-dd HH:mm:ss,SSS" ] 
        }
        #filter { ruby { code => "" } }
    }
    if [type] == "log4j" and "multiline" in [tags] {
        grok { match => [ "message", "%{JAVASTACKTRACEPART}" ] }
    }
    if [logmessage] =~ "(Analysing\ document)" {
        mutate { add_tag => [ "tag_a", "tag_u" ] }
    }
    if [logmessage] =~ "(Doc\ ID\:)" {
        mutate { add_tag => [ "tag_d", "tag_u" ] }
    }
    if [logmessage] =~ "(\[\'index\:)" {
        mutate { add_tag => [ "tag_i", "tag_u" ] }
    }
    if "tag_u" not in [tags] {
        ruby { code => "event.cancel" }
    }
}

output {
#   stdout
    myout {
        codec => rubydebug
#        debug => true
    }
}
